<#@ include file="ChecksumHashCalculator.ttinclude" #><#+
private void WriteLicenseValidationCache(string nameSpace, string className)
{
#>//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on <#= DateTimeOffset.Now.ToString("o") #>.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
<#+
    var apolloUtilsNamespace = "Apollo.Utils";
    if (!string.Equals(nameSpace, apolloUtilsNamespace))
    {
#>
using Apollo.Utils;
<#+
    }
#>
<#+
    var apolloLicensingNamespace = "Apollo.Utils.Licensing";
    if (!string.Equals(nameSpace, apolloLicensingNamespace))
    {
#>
using Apollo.Utils.Licensing;
<#+
    }
#>
using Lokad;

namespace <#= nameSpace #>
{
    /// <summary>
    /// Implements the <see cref="ILicenseValidationCache" /> interface.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("TextTemplatingFileGenerator", "10.0.0.0")]
    internal sealed class <#= className #> : ILicenseValidationCache
    {
        /// <summary>
        /// The object used to lock on.
        /// </summary>
        private readonly ILockObject m_Lock = new LockObject();

        /// <summary>
        /// The object that performs the actual license validation.
        /// </summary>
        private readonly IValidator m_Validator;
        
        /// <summary>
        /// The function that returns the current time.
        /// </summary>
        private readonly Func<DateTimeOffset> m_Now;

        /// <summary>
        /// The function that returns a random double in the
        /// range [0, 1].
        /// </summary>
        private readonly Func<double> m_Random;

<#+
    string lastResultField = "m_LastResult";
#>
        /// <summary>
        /// The latest license validation result.
        /// </summary>
        private LicenseCheckResult <#= lastResultField #>;

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= className #>"/> class.
        /// </summary>
        /// <param name="validator">The validator that performs the actual license validation.</param>
        /// <param name="now">The function that returns the current time.</param>
        /// <param name="randomizer">The function that returns a random double in the range [0, 1].</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="validator"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="now"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="randomizer"/> is <see langword="null"/>.
        /// </exception>
        public <#= className #>(IValidator validator, Func<DateTimeOffset> now, Func<double> randomizer)
        {
            {
                Enforce.Argument(() => validator);
                Enforce.Argument(() => now);
                Enforce.Argument(() => randomizer);
            }

            m_Validator = validator;
            m_Now = now;
            m_Random = randomizer;

<#+
    string generationVariable = "generationTime";
    string expirationVariable = "expirationTime";
#>
            // Store the generation time and the expiration time. At the moment we'll assume
            // a 30 second expiration time. Later on we should probably generate this arbitrairily.
            var <#= generationVariable #> = m_Now();
            var <#= expirationVariable #> = <#= generationVariable #>.Add(new TimeSpan(0, 0, 30));

<#+
    var checksumVariable = "checksum";
#>
            var <#= checksumVariable #> = new Checksum(<#= successText #>, <#= generationVariable #>, <#= expirationVariable #>);
            <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
        }

        /// <summary>
        /// Gets the latest validation result.
        /// </summary>
        /// <value>The latest result.</value>
        public LicenseCheckResult LatestResult
        {
            get
            {
                return m_LastResult;
            }
        }

        /// <summary>
        /// Gets the last validation time.
        /// </summary>
        /// <value>The last validatio time.</value>
        public DateTimeOffset LastValidationTime
        {
            get
            {
                return m_LastResult.Generated;
            }
        }

        /// <summary>
        /// Invalidates the cache and gets a new <see cref="LicenseCheckResult"/> with the specified expiration time.
        /// </summary>
        /// <param name="nextExpiration">
        /// The <see cref="TimePeriod"/> that must occur before the validated license check expires.
        /// </param>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes",
            Justification = "We don't want any exception to escape from here. In production we'll kill the app anyway.")]
        public void Invalidate(TimePeriod nextExpiration)
        {
            // Store the generation time of the result that matches our expiry time period clostest.
            var bestMatchingGenerationTime = m_Now();
            
            // By setting the differential ticks to the number of ticks from now to
            // our desired expiry time we will either find something slightly shorter
            // or nothing. If nothing then we'll validate.
            var ourTicks = nextExpiration.RepeatAfter(m_Now()).Ticks;
            var differentialTicks = ourTicks;
            var result = m_LastResult;

            // If there is a success result then we grab 
            // the expiry time
            var expiryPeriod = result.Expires - result.Generated;
            var difference = Math.Abs(expiryPeriod.Ticks - ourTicks);
            if (difference < differentialTicks)
            {
                bestMatchingGenerationTime = result.Generated;
                differentialTicks = difference;
            }

            // Calculate the number of ticks left in the expiration time. Then
            // calculate the probability for validation in the range [0, 1] where
            // 1 is 100% of validation.
            var originalTicks = (bestMatchingGenerationTime - m_Now()).Ticks;

            // The validationPossibility can be between 0 (originalTicks == 0 because generationTime == now) and 
            // 1 (originalTick >= ourTicks because generationTime is larger than our expiry time period).
            var validationPossibility = Math.Min(Math.Abs((double)originalTicks / (double)ourTicks), 1);
            var value = m_Random();

            // If the value is less than the validationPossibility then we'll need to validate
            // given that validationPossibility will be 1.0 if we should validate.
            // Given that the validationPossibility approaches 1 when we're approaching
            // the expiry time we'll be more likely to validate if the original validation is
            // about to expire.
            if (value < validationPossibility)
            {
                // If we do validate then we call into the validation library
                // and wait for the result. --> DONE
                bool isValid = false;
                try
                {
                    isValid = m_Validator.Validate();
                }
                catch(Exception)
                {
                    var <#= generationVariable #> = m_Now();
                    var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                    var <#= checksumVariable #> = new Checksum(<#= failureText #>, <#= generationVariable #>, <#= expirationVariable #>);
                    <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
                    return;
                }

                // check if the validation was successful
                if (isValid)
                {
                    // If we do not validate then grab the success result and 
                    // build our own checksum
                    var <#= generationVariable #> = m_Now();
                    var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                    var <#= checksumVariable #> = new Checksum(<#= successText #>, <#= generationVariable #>, <#= expirationVariable #>);
                    <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
                }
                else
                {
                    // If we do not validate then grab the success result and 
                    // build our own checksum
                    var <#= generationVariable #> = m_Now();
                    var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                    var <#= checksumVariable #> = new Checksum(<#= failureText #>, <#= generationVariable #>, <#= expirationVariable #>);
                    <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
                }
            }
            else
            {
                // If we do not validate then grab the success result and 
                // build our own checksum
                var <#= generationVariable #> = m_Now();
                var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                var <#= checksumVariable #> = new Checksum(<#= successText #>, <#= generationVariable #>, <#= expirationVariable #>);
                <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
            }
        }
    }
}
<#+
}
#>