<#+
public enum ElementType
{
    @class,
    sealedClass,
    @struct,
}

private string ElementSignature(ElementType elementType)
{
    switch (elementType)
    {
        case ElementType.@class :
            return "partial class";
        case ElementType.sealedClass :
            return "sealed partial class";
        case ElementType.@struct :
            return "partial struct";
        default:
            throw new NotImplementedException();
    }
}

private void WritePartialElementWithOnValidationResult(string nameSpace, string modifier, ElementType elementType, string name)
{
#>
//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics;
#if DEPLOY
using System.Globalization;
#endif
using System.Timers;
using Apollo.Utilities;
using Apollo.Utilities.Licensing;

namespace <#= nameSpace #>
{
    /// <summary>
    /// Stores information about a checksum that is used by the verification system.
    /// </summary>
    <#= modifier #> <#= ElementSignature(elementType) #> <#= name #>
    {
        /// <summary>
        /// The object that is used to lock on.
        /// </summary>
        private readonly ILockObject m_Lock = new LockObject();

        /// <summary>
        /// Used to make sure that the license validations come through regularly.
        /// </summary>
        private readonly Timer m_Timer = new Timer(LicensingConstants.LicenseWatchdogIntervalInMilliseconds);

        /// <summary>
        /// The date / time that the last heart beat was received from the validation service.
        /// </summary>
        private DateTimeOffset m_TimeOfLastHeartbeat;

        /// <summary>
        /// Starts the validation watchdog timer.
        /// </summary>
        private void StartWatchdog()
        {
            m_Timer.AutoReset = true;
            m_Timer.Elapsed += (s, e) => OnWatchdogUpdate();

            m_Timer.Start();
        }

        /// <summary>
        /// Processes the updates from the timer thread.
        /// </summary>
        private void OnWatchdogUpdate()
        { 
            var lastHeartbeat = DateTimeOffset.MinValue;
            lock (m_Lock)
            {
                Debug.Assert(!m_TimeOfLastHeartbeat.Equals(DateTimeOffset.MinValue), "Failure to update the licence watch dog.");
                lastHeartbeat = m_TimeOfLastHeartbeat;
            }

            var maximumInterval = new TimeSpan(0, 0, 0, 0, LicensingConstants.MaximumNumberOfSequentialValidationFailures * LicensingConstants.LicenseWatchdogIntervalInMilliseconds);
            var interval = DateTimeOffset.Now - lastHeartbeat;

            // If we have surpassed the maximum time interval then we exit immediately
            if (interval > maximumInterval)
            { 
                // If we aren't in deploy mode then we simply throw an exception. 
                // Chances are that it'll be unhandled and take the app down. In
                // deploy mode we take the app down ourselves.
#if !DEPLOY
                throw new LicenseValidationFailedException();
#else
                Environment.FailFast(
                    string.Format(
                        CultureInfo.InvariantCulture,
                        SrcOnlyResources.ExceptionMessagesInternalErrorWithCode,
                        ErrorCodes.ValidationExceededMaximumSequentialFailures));
#endif
            }
        }

        /// <summary>
        /// Handles the license validation heart beats.
        /// </summary>
        /// <param name="dateTime">The time a heart beat happened.</param>
        private void VerifyLicenseValidationServiceIsAlive(DateTimeOffset dateTime)
        {
            // If the heart beat time is in the future we just ignore it
            // Note that it is allowed to be slightly in the future to 
            // prevent issues with the fact that modern CPU's are quite 
            // capable of handling many instructions per time unit.
            if (dateTime > (DateTimeOffset.Now.AddTicks(LicensingConstants.ThresholdForTimeDeviationsInTicks)))
            {
                return;
            }

            lock(m_Lock)
            {
                if (m_TimeOfLastHeartbeat < dateTime)
                {
                    m_TimeOfLastHeartbeat = dateTime;
                }
            }
        }
    }
}
<#+
}
#>