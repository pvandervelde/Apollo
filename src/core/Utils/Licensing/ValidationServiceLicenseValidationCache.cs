//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on 2011-01-25T21:23:14.3348987+13:00.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using Apollo.Utils;
using Apollo.Utils.Licensing;
using Lokad;

namespace Apollo.Core.Utils.Licensing
{
    /// <summary>
    /// Implements the <see cref="ILicenseValidationCache" /> interface.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("TextTemplatingFileGenerator", "10.0.0.0")]
    internal sealed class ValidationServiceLicenseValidationCache : ILicenseValidationCache
    {
        /// <summary>
        /// The object that performs the actual license validation.
        /// </summary>
        private readonly IValidator m_Validator;
        
        /// <summary>
        /// The function that returns the current time.
        /// </summary>
        private readonly Func<DateTimeOffset> m_Now;

        /// <summary>
        /// The function that returns a random double in the
        /// range [0, 1].
        /// </summary>
        private readonly Func<double> m_Random;

        /// <summary>
        /// The latest license validation result.
        /// </summary>
        private LicenseCheckResult m_LastResult;

        /// <summary>
        /// Initializes a new instance of the <see cref="ValidationServiceLicenseValidationCache"/> class.
        /// </summary>
        /// <param name="validator">The validator that performs the actual license validation.</param>
        /// <param name="now">The function that returns the current time.</param>
        /// <param name="randomizer">The function that returns a random double in the range [0, 1].</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="validator"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="now"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="randomizer"/> is <see langword="null"/>.
        /// </exception>
        public ValidationServiceLicenseValidationCache(IValidator validator, Func<DateTimeOffset> now, Func<double> randomizer)
        {
            {
                Enforce.Argument(() => validator);
                Enforce.Argument(() => now);
                Enforce.Argument(() => randomizer);
            }

            m_Validator = validator;
            m_Now = now;
            m_Random = randomizer;

            // Store the generation time and the expiration time. At the moment we'll assume
            // a 30 second expiration time. Later on we should probably generate this arbitrairily.
            var generationTime = m_Now();
            var expirationTime = generationTime.Add(new TimeSpan(0, 0, 30));

            var checksum = new Checksum("ValidationSuccess", generationTime, expirationTime);
            m_LastResult = new LicenseCheckResult(generationTime, expirationTime, checksum);
        }

        /// <summary>
        /// Gets the latest validation result.
        /// </summary>
        /// <value>The latest result.</value>
        public LicenseCheckResult LatestResult
        {
            get
            {
                return m_LastResult;
            }
        }

        /// <summary>
        /// Gets the last validation time.
        /// </summary>
        /// <value>The last validatio time.</value>
        public DateTimeOffset LastValidationTime
        {
            get
            {
                return m_LastResult.Generated;
            }
        }

        /// <summary>
        /// Invalidates the cache and gets a new <see cref="LicenseCheckResult"/> with the specified expiration time.
        /// </summary>
        /// <param name="nextExpiration">
        /// The <see cref="TimePeriod"/> that must occur before the validated license check expires.
        /// </param>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes",
            Justification = "We don't want any exception to escape from here. In production we'll kill the app anyway.")]
        public void Invalidate(TimePeriod nextExpiration)
        {
            var bestMatchingGenerationTime = m_Now();
            
            // By setting the differential ticks to the number of ticks from now to
            // our desired expiry time we will either find something slightly shorter
            // or nothing. If nothing then we'll validate.
            var ourTicks = nextExpiration.RepeatAfter(m_Now()).Ticks;
            var differentialTicks = ourTicks;
            var result = m_LastResult;

            // If there is a success result then we grab 
            // the expiry time
            var expiryPeriod = result.Expires - result.Generated;
            var difference = Math.Abs(expiryPeriod.Ticks - ourTicks);
            if (difference < differentialTicks)
            {
                bestMatchingGenerationTime = result.Generated;
                differentialTicks = difference;
            }

            // Calculate the number of ticks left in the expiration time. Then
            // calculate the probability for validation in the range [0, 1] where
            // 1 is 100% of validation.
            var originalTicks = (bestMatchingGenerationTime - m_Now()).Ticks;

            // The validationPossibility can be between 0 (originalTicks == 0 because generationTime == now) and 
            // 1 (originalTick >= ourTicks because generationTime is larger than our expiry time period).
            var validationPossibility = Math.Min(Math.Abs((double)originalTicks / (double)ourTicks), 1);
            var value = m_Random();

            // If the value is less than the validationPossibility then we'll need to validate
            // given that validationPossibility will be 1.0 if we should validate.
            // Given that the validationPossibility approaches 1 when we're approaching
            // the expiry time we'll be more likely to validate if the original validation is
            // about to expire.
            if (value < validationPossibility)
            {
                // If we do validate then we call into the validation library
                // and wait for the result. --> DONE
                bool isValid = false;
                try
                {
                    isValid = m_Validator.Validate();
                }
                catch(Exception)
                {
                    var generationTime = m_Now();
                    var expirationTime = generationTime + nextExpiration.RepeatAfter(generationTime);

                    var checksum = new Checksum("ValidationFailure", generationTime, expirationTime);
                    m_LastResult = new LicenseCheckResult(generationTime, expirationTime, checksum);
                    return;
                }

                if (isValid)
                {
                    // If we do not validate then grab the success result and 
                    // build our own checksum
                    var generationTime = m_Now();
                    var expirationTime = generationTime + nextExpiration.RepeatAfter(generationTime);

                    var checksum = new Checksum("ValidationSuccess", generationTime, expirationTime);
                    m_LastResult = new LicenseCheckResult(generationTime, expirationTime, checksum);
                }
                else
                {
                    // If we do not validate then grab the success result and 
                    // build our own checksum
                    var generationTime = m_Now();
                    var expirationTime = generationTime + nextExpiration.RepeatAfter(generationTime);

                    var checksum = new Checksum("ValidationFailure", generationTime, expirationTime);
                    m_LastResult = new LicenseCheckResult(generationTime, expirationTime, checksum);
                }
            }
            else
            {
                // If we do not validate then grab the success result and 
                // build our own checksum
                var generationTime = m_Now();
                var expirationTime = generationTime + nextExpiration.RepeatAfter(generationTime);

                var checksum = new Checksum("ValidationSuccess", generationTime, expirationTime);
                m_LastResult = new LicenseCheckResult(generationTime, expirationTime, checksum);
            }
        }
    }
}
