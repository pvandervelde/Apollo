<#@ include file="..\..\..\utilities.srconly\Licensing\ChecksumHashCalculator.ttinclude" #><#+
private void WriteLicenseValidationCacheTest(string nameSpace, string className, string classUnderTest)
{
#>//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on <#= DateTimeOffset.Now.ToString("o") #>.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;
<#+
var apolloLicensingNamespace = "Apollo.Utilities.Licensing";
if (!string.Equals(nameSpace, apolloLicensingNamespace))
{
#>
using Apollo.Utilities.Licensing;
<#+
}
#>
using MbUnit.Framework;
using Moq;

namespace <#= nameSpace #>
{
    [TestFixture]
    [Description("Tests the <#= className #> class.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented",
            Justification = "Unit tests do not need documentation.")]
    public sealed class <#= className #>
    {
        [Test]
        [Description("Checks that an object cannot be created with a null validator reference.")]
        public void CreateWithNullValidator()
        { 
            Assert.Throws<ArgumentNullException>(() => new <#= classUnderTest #>(null, () => DateTimeOffset.Now, () => 42.0));
        }

        [Test]
        [Description("Checks that an object cannot be created with a null time function reference.")]
        public void CreateWithNullTimeFunction()
        {
            Assert.Throws<ArgumentNullException>(() => new <#= classUnderTest #>(new Mock<IValidator>().Object, null, () => 42.0));
        }

        [Test]
        [Description("Checks that an object cannot be created with a null randomizer reference.")]
        public void CreateWithNullRandomizer()
        {
            Assert.Throws<ArgumentNullException>(() => new <#= classUnderTest #>(new Mock<IValidator>().Object, () => DateTimeOffset.Now, null));
        }

        [Test]
        [Description("Checks that the constructor sets the LatestResult to the correct value.")]
        public void Create()
        {
            var now = DateTimeOffset.Now;
            var cache = new <#= classUnderTest #>(new Mock<IValidator>().Object, () => now, () => 42.0);

            Assert.IsTrue(now.EqualsExact(cache.LastValidationTime), "expected: {0}; value: {1}", now.ToString("o"), cache.LastValidationTime.ToString("o"));
            Assert.AreEqual(now.AddSeconds(30), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a failure result when the validation calculation throws an exception.")]
        public void InvalidateWithValidationThatThrowsAnException()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Callback(() => { throw new Exception(); })
                    .Returns(true);
            }

            // The validation possibility is 1/12 (5/60) so in order to validate
            // we have to provide a number smaller than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0832;
            var cache = new <#= classUnderTest #>(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum(<#= failureText #>, now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a success result when called with no validation calculation.")]
        public void InvalidateWithoutValidating()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(false);
            }

            // The validation possibility is 1/12 (5/60) so in order to not validate
            // we have to provide a number larger than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0835;
            var cache = new <#= classUnderTest #>(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum(<#= successText #>, now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a success result when called with a validation calculation.")]
        public void InvalidateWithSuccessValidation()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(true);
            }

            // The validation possibility is 1/12 (5/60) so in order to validate
            // we have to provide a number smaller than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0832;
            var cache = new <#= classUnderTest #>(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum(<#= successText #>, now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a failure result when called with a validation calculation.")]
        public void InvalidateWithFailureValidation()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(false);
            }

            // The validation possibility is 1/12 (5/60) so in order to validate
            // we have to provide a number smaller than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0832;
            var cache = new <#= classUnderTest #>(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum(<#= failureText #>, now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method does a validation calculation if the result has expired longer ago than the period time.")]
        public void InvalidateWithMatchingTimeExpiredLongerThanThePeriodTime()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(true);
            }

            // The validation possibility is 1 (Min(80/60, 1)) so in order to validate
            // we have to provide a number smaller than 1
            Func<double> randomizer = () => 0.99;
            var cache = new <#= classUnderTest #>(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum(<#= successText #>, now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method does a validation calculation if the result has expired shorter ago than the period time.")]
        public void InvalidateWithMatchingTimeExpiredShorterThanThePeriodTime()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(true);
            }

            // The validation possibility is 2/3 (Min(40/60, 1)) so in order to validate
            // we have to provide a number smaller than 2/3 = 0.6666667
            Func<double> randomizer = () => 0.66;
            var cache = new <#= classUnderTest #>(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum(<#= successText #>, now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }
    }
}
<#+
}
#>
