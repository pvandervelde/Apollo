//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on 2011-05-21T22:21:32.6884639+12:00.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;
using Apollo.Utilities.Licensing;
using MbUnit.Framework;
using Moq;

namespace Apollo.Core.Utilities.Licensing
{
    [TestFixture]
    [Description("Tests the ValidationServiceLicenseValidationCacheTest class.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented",
            Justification = "Unit tests do not need documentation.")]
    public sealed class ValidationServiceLicenseValidationCacheTest
    {
        [Test]
        [Description("Checks that the constructor sets the LatestResult to the correct value.")]
        public void Create()
        {
            var now = DateTimeOffset.Now;
            var cache = new ValidationServiceLicenseValidationCache(new Mock<IValidator>().Object, () => now, () => 42.0);

            Assert.IsTrue(now.EqualsExact(cache.LastValidationTime), "expected: {0}; value: {1}", now.ToString("o"), cache.LastValidationTime.ToString("o"));
            Assert.AreEqual(now.AddSeconds(30), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a failure result when the validation calculation throws an exception.")]
        public void InvalidateWithValidationThatThrowsAnException()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Callback(() => { throw new Exception(); })
                    .Returns(true);
            }

            // The validation possibility is 1/12 (5/60) so in order to validate
            // we have to provide a number smaller than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0832;
            var cache = new ValidationServiceLicenseValidationCache(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum("ValidationFailure", now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a success result when called with no validation calculation.")]
        public void InvalidateWithoutValidating()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(false);
            }

            // The validation possibility is 1/12 (5/60) so in order to not validate
            // we have to provide a number larger than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0835;
            var cache = new ValidationServiceLicenseValidationCache(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum("ValidationSuccess", now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a success result when called with a validation calculation.")]
        public void InvalidateWithSuccessValidation()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(true);
            }

            // The validation possibility is 1/12 (5/60) so in order to validate
            // we have to provide a number smaller than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0832;
            var cache = new ValidationServiceLicenseValidationCache(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum("ValidationSuccess", now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method sets a failure result when called with a validation calculation.")]
        public void InvalidateWithFailureValidation()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(false);
            }

            // The validation possibility is 1/12 (5/60) so in order to validate
            // we have to provide a number smaller than 1/12 = 0.0833333333
            Func<double> randomizer = () => 0.0832;
            var cache = new ValidationServiceLicenseValidationCache(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum("ValidationFailure", now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method does a validation calculation if the result has expired longer ago than the period time.")]
        public void InvalidateWithMatchingTimeExpiredLongerThanThePeriodTime()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(true);
            }

            // The validation possibility is 1 (Min(80/60, 1)) so in order to validate
            // we have to provide a number smaller than 1
            Func<double> randomizer = () => 0.99;
            var cache = new ValidationServiceLicenseValidationCache(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum("ValidationSuccess", now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }

        [Test]
        [Description("Checks that the Invalidate method does a validation calculation if the result has expired shorter ago than the period time.")]
        public void InvalidateWithMatchingTimeExpiredShorterThanThePeriodTime()
        { 
            var now = DateTimeOffset.Now;
            var validator = new Mock<IValidator>();
            {
                validator.Setup(v => v.Validate())
                    .Returns(true);
            }

            // The validation possibility is 2/3 (Min(40/60, 1)) so in order to validate
            // we have to provide a number smaller than 2/3 = 0.6666667
            Func<double> randomizer = () => 0.66;
            var cache = new ValidationServiceLicenseValidationCache(validator.Object, () => now, randomizer);

            now = now.AddMinutes(5);
            cache.Invalidate(new TimePeriod(RepeatPeriod.Hourly));
            var checksum = new Checksum("ValidationSuccess", now, now.AddHours(1));
            Assert.AreEqual(checksum, cache.LatestResult.Checksum);
            Assert.AreEqual(now, cache.LatestResult.Generated);
            Assert.AreEqual(now.AddHours(1), cache.LatestResult.Expires);
        }
    }
}
