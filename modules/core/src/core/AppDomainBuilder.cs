//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Reflection;
using System.Security.Permissions;
using Apollo.Utils.ExceptionHandling;
using Lokad;

namespace Apollo.Core
{
    /// <summary>
    /// Builds AppDomains with unhandled exception handlers and fusion loading events.
    /// </summary>
    internal sealed partial class AppDomainBuilder
    {
        /// <summary>
        /// The default friendly name.
        /// </summary>
        private const string s_DefaultFriendlyName = "AppDomain generated by Apollo.Core";

        /// <summary>
        /// Generates the new name of the app domain.
        /// </summary>
        /// <returns>The newly generated <c>AppDomain</c> name.</returns>
        private static string GenerateNewAppDomainName()
        {
            return s_DefaultFriendlyName;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/>.
        /// </summary>
        /// <param name="name">The friendly name of the new <c>AppDomain</c>.</param>
        /// <param name="basePath">The base path for the new <c>AppDomain</c>.</param>
        /// <returns>
        ///     The newly created <c>AppDomain</c>.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters",
            Justification = "We do really want a directory and not a file system object, therefore we shall stick with DirectoryInfo.")]
        private static AppDomain Create(string name, DirectoryInfo basePath)
        {
            {
                Debug.Assert(basePath != null, "The base path must be defined");
                Debug.Assert(basePath.Exists, "The base path must be a valid path");
            }

            var setup = new AppDomainSetup 
                {
                    ApplicationName = Assembly.GetCallingAssembly().GetName().Name, 
                    ApplicationBase = basePath.FullName
                };

            // If the basePath is not equal to the file path of the current assembly (i.e. Apollo.Core)
            // then we add the path of the current assembly as private bin path.
            var corePath = new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath;
            if (!string.Equals(corePath, basePath.FullName, StringComparison.OrdinalIgnoreCase))
            {
                // Note that this could be a security risk. If we always have the core bin path, then 
                // we can always load the core ... Doesn't seem right.
                setup.PrivateBinPath = Path.GetDirectoryName(corePath);
            }

            // Do not shadow copy files. We don't want people able to move / change assemblies 
            // if we are using them. Also shadow copying only affects files on the 
            // base path and the private bin path, so the files found through
            // the assembly resolver will not be shadow copied. Because we will use the
            // assembly resolver extensively there will be many files that can't be shadow
            // copied. So in order to be consistent we will not shadow copy any files.
            setup.ShadowCopyFiles = "false";

            // do not allow random assembly downloads
            setup.DisallowCodeDownload = true;

            var result = AppDomain.CreateDomain(
                string.IsNullOrEmpty(name) ? GenerateNewAppDomainName() : name,
                null,
                setup);
            return result;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="basePath">The base path for the new <c>AppDomain</c>.</param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic",
            Justification = "Making this method static would lead to a static class which makes testing harder.")]
        public AppDomain AssembleWithFilePaths(DirectoryInfo basePath, IEnumerable<string> assemblyFiles, IExceptionHandler exceptionHandler)
        {   
            return AssembleWithFilePaths(string.Empty, basePath, assemblyFiles, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">
        ///     The friendly name of the new <c>AppDomain</c>.
        /// </param>
        /// <param name="basePath">
        ///     The base path for the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic",
            Justification = "Making this method static would lead to a static class which makes testing harder.")]
        public AppDomain AssembleWithFilePaths(string friendlyName, DirectoryInfo basePath, IEnumerable<string> assemblyFiles, IExceptionHandler exceptionHandler)
        {
            return AssembleWithFileAndDirectoryPaths(friendlyName, basePath, assemblyFiles, null, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">
        ///     The friendly name of the new <c>AppDomain</c>.
        /// </param>
        /// <param name="basePath">
        ///     The base path for the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyDirectories">
        ///     The directories from which assemblies are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic",
            Justification = "Making this method static would lead to a static class which makes testing harder.")]
        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlAppDomain)]
        public AppDomain AssembleWithFileAndDirectoryPaths(string friendlyName, DirectoryInfo basePath, IEnumerable<string> assemblyFiles, IEnumerable<string> assemblyDirectories, IExceptionHandler exceptionHandler)
        {
            {
                Enforce.Argument(() => basePath);
                Enforce.That(() => basePath.Exists);

                Enforce.Argument(() => exceptionHandler);
            }

            var domain = Create(friendlyName, basePath);

            // Attach to the assembly file resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection wouldn't fill up later.
            if (assemblyFiles != null)
            {
                var resolver = domain.CreateInstanceAndUnwrap(
                    typeof(FileBasedResolver).Assembly.FullName,
                    typeof(FileBasedResolver).FullName) as FileBasedResolver;

                Debug.Assert(resolver != null, "Somehow we didn't create a resolver.");
                resolver.StoreFilePaths(assemblyFiles);
                resolver.Attach();
            }

            // Attach to the assembly directory resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection wouldn't fill up later.
            if (assemblyDirectories != null)
            {
                var resolver = domain.CreateInstanceAndUnwrap(
                    typeof(DirectoryBasedResolver).Assembly.FullName,
                    typeof(DirectoryBasedResolver).FullName) as DirectoryBasedResolver;

                Debug.Assert(resolver != null, "Somehow we didn't create a resolver.");
                resolver.StoreDirectoryPaths(assemblyDirectories);
                resolver.Attach();
            }

            // Attach the exception handler
            {
                domain.UnhandledException += exceptionHandler.OnUnhandledException;
            }

            return domain;
        }
    }
}
