//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using Apollo.Utils.ExceptionHandling;
using Lokad;

namespace Apollo.Core
{
    /// <summary>
    /// Builds AppDomains with unhandled exception handlers and fusion loading events.
    /// </summary>
    internal sealed partial class AppDomainBuilder
    {
        /// <summary>
        /// The default friendly name.
        /// </summary>
        private const string s_DefaultFriendlyName = "AppDomain generated by Apollo.Core";

        /// <summary>
        /// Creates a new <see cref="AppDomain"/>.
        /// </summary>
        /// <param name="name">The friendly name of the new <c>AppDomain</c>.</param>
        /// <param name="basePath">The base path for the new <c>AppDomain</c>.</param>
        /// <returns>
        ///     The newly created <c>AppDomain</c>.
        /// </returns>
        private AppDomain Create(string name, DirectoryInfo basePath)
        {
            {
                Debug.Assert(basePath != null, "The base path must be defined");
                Debug.Assert(basePath.Exists, "The base path must be a valid path");
            }

            AppDomainSetup setup = new AppDomainSetup();
            setup.ApplicationName = Assembly.GetCallingAssembly().GetName().Name;
            setup.ApplicationBase = basePath.FullName;

            // If the basePath is not equal to the file path of the current assembly (i.e. Apollo.Core)
            // then we add the path of the current assembly as private bin path.
            string corePath = new Uri(Assembly.GetExecutingAssembly().CodeBase).LocalPath;
            if (!string.Equals(corePath, basePath.FullName, StringComparison.InvariantCultureIgnoreCase))
            {
                setup.PrivateBinPath = Path.GetDirectoryName(corePath);
            }

            // Do not shadow copy files. We don't want people able to move / change assemblies 
            // if we are using them. Also shadow copying only affects files on the 
            // base path and the private bin path, so the files found through
            // the assembly resolver will not be shadow copied. Because we will use the
            // assembly resolver extensively there will be many files that can't be shadow
            // copied. So in order to be consistent we will not shadow copy any files.
            setup.ShadowCopyFiles = "false";

            // do not allow random assembly downloads
            setup.DisallowCodeDownload = true;

            AppDomain result = AppDomain.CreateDomain(
                string.IsNullOrEmpty(name) ? GenerateNewAppDomainName() : name,
                null,
                setup);
            return result;
        }

        private string GenerateNewAppDomainName()
        {
            return s_DefaultFriendlyName;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="basePath">The base path for the new <c>AppDomain</c>.</param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        public AppDomain AssembleWithFilePaths(DirectoryInfo basePath, Func<IEnumerable<string>> assemblyFiles, IExceptionHandler exceptionHandler)
        {   
            return AssembleWithFilePaths(string.Empty, basePath, assemblyFiles, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">
        ///     The friendly name of the new <c>AppDomain</c>.
        /// </param>
        /// <param name="basePath">
        ///     The base path for the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        public AppDomain AssembleWithFilePaths(string friendlyName, DirectoryInfo basePath, Func<IEnumerable<string>> assemblyFiles, IExceptionHandler exceptionHandler)
        {
            return AssembleWithFileAndDirectoryPaths(friendlyName, basePath, assemblyFiles, null, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="basePath">The base path for the new <c>AppDomain</c>.</param>
        /// <param name="assemblyDirectories">
        ///     The directories from which assemblies are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        public AppDomain AssembleWithDirectoryPaths(DirectoryInfo basePath, Func<IEnumerable<string>> assemblyDirectories, IExceptionHandler exceptionHandler)
        {
            return AssembleWithDirectoryPaths(string.Empty, basePath, assemblyDirectories, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">
        ///     The friendly name of the new <c>AppDomain</c>.
        /// </param>
        /// <param name="basePath">
        ///     The base path for the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyDirectories">
        ///     The directories from which assemblies are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        public AppDomain AssembleWithDirectoryPaths(string friendlyName, DirectoryInfo basePath, Func<IEnumerable<string>> assemblyDirectories, IExceptionHandler exceptionHandler)
        {
            return AssembleWithFileAndDirectoryPaths(friendlyName, basePath, null, assemblyDirectories, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="basePath">The base path for the new <c>AppDomain</c>.</param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyDirectories">
        ///     The directories from which assemblies are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        public AppDomain AssembleWithFileAndDirectoryPaths(DirectoryInfo basePath, Func<IEnumerable<string>> assemblyFiles, Func<IEnumerable<string>> assemblyDirectories, IExceptionHandler exceptionHandler)
        {
            return AssembleWithFileAndDirectoryPaths(string.Empty, basePath, assemblyFiles, assemblyDirectories, exceptionHandler);
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">
        ///     The friendly name of the new <c>AppDomain</c>.
        /// </param>
        /// <param name="basePath">
        ///     The base path for the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyFiles">
        ///     The assembly files which are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="assemblyDirectories">
        ///     The directories from which assemblies are allowed to be loaded into the new <c>AppDomain</c>.
        /// </param>
        /// <param name="exceptionHandler">
        ///     The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.
        /// </param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <design>
        ///     If the <paramref name="basePath"/> is not the path of the current (i.e. Apollo.Core) assembly
        ///     then a private path to the current assembly will be added to ensure that we can always load
        ///     this assembly. This is necessary so that the assembly resolvers etc. can be loaded into the
        ///     new <c>AppDomain</c>.
        /// </design>
        public AppDomain AssembleWithFileAndDirectoryPaths(string friendlyName, DirectoryInfo basePath, Func<IEnumerable<string>> assemblyFiles, Func<IEnumerable<string>> assemblyDirectories, IExceptionHandler exceptionHandler)
        {
            {
                Enforce.Argument(() => basePath);
                Enforce.That(() => basePath.Exists);

                Enforce.Argument(() => exceptionHandler);
            }

            var domain = Create(friendlyName, basePath);

            // Attach to the assembly file resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection wouldn't fill up later.
            if (assemblyFiles != null)
            {
                var resolver = domain.CreateInstanceAndUnwrap(
                    typeof(FileBasedResolver).Assembly.FullName,
                    typeof(FileBasedResolver).FullName) as FileBasedResolver;
                resolver.StoreFilePaths(assemblyFiles);
                resolver.Attach();
            }

            // Attach to the assembly directory resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection wouldn't fill up later.
            if (assemblyDirectories != null)
            {
                var resolver = domain.CreateInstanceAndUnwrap(
                    typeof(DirectoryBasedResolver).Assembly.FullName,
                    typeof(DirectoryBasedResolver).FullName) as DirectoryBasedResolver;
                resolver.StoreDirectoryPaths(assemblyDirectories);
                resolver.Attach();
            }

            // Attach the exception handler
            {
                domain.UnhandledException += new UnhandledExceptionEventHandler(exceptionHandler.OnUnhandledException);
            }

            return domain;
        }
    }
}
