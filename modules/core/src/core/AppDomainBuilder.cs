//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Security.Permissions;
using Apollo.Utils;
using Apollo.Utils.ExceptionHandling;
using Lokad;
using Lokad.Quality;

namespace Apollo.Core
{
    /// <summary>
    /// Builds AppDomains with unhandled exception handlers and fusion loading events.
    /// </summary>
    internal static partial class AppDomainBuilder
    {
        /// <summary>
        /// The default friendly name.
        /// </summary>
        private const string s_DefaultFriendlyName = "AppDomain generated by Apollo.Core";

        /// <summary>
        /// Generates the new name of the app domain.
        /// </summary>
        /// <returns>The newly generated <c>AppDomain</c> name.</returns>
        private static string GenerateNewAppDomainName()
        {
            return s_DefaultFriendlyName;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/>.
        /// </summary>
        /// <param name="name">The friendly name of the new <c>AppDomain</c>.</param>
        /// <param name="sandboxData">The sandbox information for the <c>AppDomain</c>.</param>
        /// <param name="resolutionPaths">The assembly resolution paths for the new <c>AppDomain</c>.</param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        [NotNull]
        [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters",
            Justification = "We do really want a directory and not a file system object, therefore we shall stick with DirectoryInfo.")]
        private static AppDomain Create(
            string name,
            AppDomainSandboxData sandboxData,
            AppDomainResolutionPaths resolutionPaths)
        {
            {
                Debug.Assert(resolutionPaths != null, "The base path must be defined");
            }

            // If the basePath is not equal to the file path of the current assembly (i.e. Apollo.Core)
            // then we explicitly do NOT add it. The plug-in domains for instance will not add the
            // core directory because that prevents them from loading any files from there.
            // The kernel assembly will be loaded by calling LoadFrom when we load the assembly resolver.
            var setup = new AppDomainSetup 
                {
                    ApplicationName = Assembly.GetCallingAssembly().GetName().Name, 
                    ApplicationBase = resolutionPaths.BasePath
                };

            // Do not shadow copy files. We don't want people able to move / change assemblies 
            // if we are using them. Also shadow copying only affects files on the 
            // base path and the private bin path, so the files found through
            // the assembly resolver will not be shadow copied. Because we will use the
            // assembly resolver extensively there will be many files that can't be shadow
            // copied. So in order to be consistent we will not shadow copy any files.
            setup.ShadowCopyFiles = "false";

            // do not allow random assembly downloads
            setup.DisallowCodeDownload = true;

            // Get the permissions
            Debug.Assert(s_SecurityLevels.ContainsKey(sandboxData.Level), "Unknown SecurityLevel found.");
            var permissions = s_SecurityLevels[sandboxData.Level]();

            // Add the permission to scan the base path
            var ioPermission = new FileIOPermission(PermissionState.Unrestricted);
            ioPermission.AddPathList(FileIOPermissionAccess.PathDiscovery, resolutionPaths.BasePath);

            // Add the file permissions
            if ((resolutionPaths.Files != null) && (resolutionPaths.Files.Exists()) ||
                ((resolutionPaths.Directories != null) && resolutionPaths.Directories.Exists()))
            {
                // Add permissions for all the assembly files
                if (resolutionPaths.Files != null)
                {
                    foreach (var file in resolutionPaths.Files)
                    {
                        ioPermission.AddPathList(FileIOPermissionAccess.Read, file);
                    }
                }

                // Add permissions for all the directories
                if (resolutionPaths.Directories != null)
                {
                    foreach (var directory in resolutionPaths.Directories)
                    {
                        ioPermission.AddPathList(FileIOPermissionAccess.Read, directory);
                    }
                }

                permissions.AddPermission(ioPermission);
            }

            // Create the AppDomain as a sandboxed AppDomain. None of the assemblies
            // will have full trust
            var result = AppDomain.CreateDomain(
                string.IsNullOrEmpty(name) ? GenerateNewAppDomainName() : name,
                null,
                setup,
                permissions,
                sandboxData.FullTrustAssemblies.ToArray());
            return result;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">The friendly name of the new <c>AppDomain</c>.</param>
        /// <param name="sandboxData">The sandbox information for the <c>AppDomain</c>.</param>
        /// <param name="resolutionPaths">The assembly resolution paths for the new <c>AppDomain</c>.</param>
        /// <param name="exceptionHandler">The exception handler which will take care of all unhandled exceptions in the
        ///     <c>AppDomain</c>.</param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        [NotNull]
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic",
            Justification = "Making this method static would lead to a static class which makes testing harder.")]
        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlAppDomain)]
        public static AppDomain Assemble(
            string friendlyName, 
            AppDomainSandboxData sandboxData, 
            AppDomainResolutionPaths resolutionPaths, 
            IExceptionHandler exceptionHandler)
        {
            {
                Enforce.Argument(() => resolutionPaths);
                Enforce.Argument(() => exceptionHandler);
            }

            var domain = Create(friendlyName, sandboxData, resolutionPaths);

            // Attach to the assembly file resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection wouldn't fill up later.
            if (resolutionPaths.Files != null)
            {
                var resolver = Activator.CreateInstanceFrom(
                    domain,
                    typeof(FileBasedResolver).Assembly.LocalFilePath(),
                    typeof(FileBasedResolver).FullName).Unwrap() as FileBasedResolver;

                Debug.Assert(resolver != null, "Somehow we didn't create a resolver.");
                resolver.StoreFilePaths(resolutionPaths.Files);
                resolver.Attach();
            }

            // Attach to the assembly directory resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection wouldn't fill up later.
            if (resolutionPaths.Directories != null)
            {
                var resolver = Activator.CreateInstanceFrom(
                    domain,
                    typeof(DirectoryBasedResolver).Assembly.LocalFilePath(),
                    typeof(DirectoryBasedResolver).FullName).Unwrap() as DirectoryBasedResolver;

                Debug.Assert(resolver != null, "Somehow we didn't create a resolver.");
                resolver.StoreDirectoryPaths(resolutionPaths.Directories);
                resolver.Attach();
            }

            // Attach the exception handler
            {
                domain.UnhandledException += exceptionHandler.OnUnhandledException;
            }

            return domain;
        }
    }
}