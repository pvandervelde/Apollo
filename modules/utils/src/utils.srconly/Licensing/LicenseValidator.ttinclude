<#@ include file="ChecksumHashCalculator.ttinclude" #>
//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

<#
WriteUsingStatementsForChecksumCalculation();
#>
<#
var apolloLicensingNamespace = "Apollo.Utils.Licensing";
if (!string.Equals(Namespace, apolloLicensingNamespace))
{
#>
using Apollo.Utils.Licensing;
<#
}
#>
using Lokad;

namespace <#= Namespace #>
{
    /// <summary>
    /// Implements the <see cref="ILicenseValidator" /> interface.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("TextTemplatingFileGenerator", "10.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal sealed class <#= this.ClassName #> : ILicenseValidator
    {
<#
    string standardExpirationTimeVariable = "s_StandardExpirationTime";
#>
        /// <summary> 
        /// The default time period used before a next license check is required.
        /// </summary>
        private static readonly TimePeriod <#= standardExpirationTimeVariable #> = new TimePeriod(RepeatPeriod.Hourly);

        /// <summary>
        /// The cache that holds the latest license verification results.
        /// </summary>
        private readonly ILicenseVerificationCache m_Cache;

        /// <summary>
        /// The delegate that is invoked each time a new validation result is available.
        /// </summary>
        private readonly LicenseResultUpdated m_OnValidationResult;

        /// <summary>
        /// A function that returns the current date &amp; time.
        /// </summary>
        private readonly Func<DateTimeOffset> m_Now;

        /// <summary>
        /// Initializes a new instance of the <see cref="<#= this.ClassName #>"/> class.
        /// </summary>
        /// <param name="cache">The cache that holds the latest verification results.</param>
        /// <param name="onValidationResult">The delegate that will be invoked each time there is a new validation result.</param>
        /// <param name="now">A function that returns the current date &amp; time.</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="cache"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="onValidationResult"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="now"/> is <see langword="null"/>.
        /// </exception>
        public <#= this.ClassName #>(
            ILicenseVerificationCache cache,
            LicenseResultUpdated onValidationResult,
            Func<DateTimeOffset> now)
        {
            {
                Enforce.Argument(() => cache);
                Enforce.Argument(() => onValidationResult);
                Enforce.Argument(() => now);
            }

            m_Cache = cache;
            m_OnValidationResult = onValidationResult;
            m_Now = now;
        }

        /// <summary>
        /// Verifies the license and stores a value based on the
        /// license validity and the checksum.
        /// </summary>
        public void Verify()
        {
<#
    WriteVerificationText(standardExpirationTimeVariable);
#>
        }

<#
    string nextExpiration = "nextExpiration";
#>
        /// <summary>
        /// Verifies the license and stores a value based on the
        /// license validity and the checksum.
        /// </summary>
        /// <param name="nextExpiration">
        /// The <see cref="TimePeriod"/> that must occur before the validated
        /// license check expires.
        /// </param>
        public void Verify(TimePeriod <#= nextExpiration #>)
        {
<#
    WriteVerificationText(nextExpiration);
#>
        }
    }
}
<#+
private void WriteVerificationText(string nextExpiration)
{
    string lastResultVariable = "lastResult";
    string hash = "generatedHash";
    
    string generationVariable = "lastResult.Expires";
    string expirationVariable = "lastResult.Expires";
    string storeIntoFailure = hash + " = ";
#>
            var <#= hash #> = string.Empty;

            // Check if the cache has a valid result
            var <#= lastResultVariable #> = m_Cache.LatestResult;

            // Define the maximum amount of time that we allow the generation time to be
            // over the current time (due to differences in timing etc.)
            var maxFutureTime = new TimeSpan(0, 0, 1);

            // if the verification is more than x seconds into the future we fail it
            if (<#= lastResultVariable #>.Generated > m_Now().Add(maxFutureTime))
            {
                // Invalidate the cache
                m_Cache.Invalidate(<#= nextExpiration #>);

                // fail the verification
<#+
    PushIndent("\t");
    WriteFailureChecksumCalculation(generationVariable, expirationVariable, storeIntoFailure);
    PopIndent();
#>
            }

            // The last verification time is not (too far) in the future so now we check if the result
            // has expired.
            if (<#= lastResultVariable #>.Expires < m_Now())
            {
                // Verification has expired. Request a new one
                m_Cache.Invalidate(<#= nextExpiration #>);
            }

            // Either the verification has not expired or we have received a new verification
            // in either case we can simply get the last verification value and pass it through.
            if (string.IsNullOrEmpty(<#= hash #>))
            {
                <#= lastResultVariable #> = m_Cache.LatestResult;
                <#= hash #> = <#= lastResultVariable#>.Checksum.ValidationHash;
            }

            var checksum = new Checksum(<#= hash #>, <#= generationVariable #>, <#= expirationVariable #>);
            m_OnValidationResult(checksum, <#= expirationVariable #>);
<#+
}
#>