<#@ include file="ChecksumHashCalculator.ttinclude" #>
//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
<#
var apolloLicensingNamespace = "Apollo.Utils.Licensing";
if (!string.Equals(Namespace, apolloLicensingNamespace))
{
#>
using Apollo.Utils.Licensing;
<#
}
#>
using Lokad;

namespace <#= Namespace #>
{
    /// <summary>
    /// Implements the <see cref="ILicenseVerificationCache" /> interface.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("TextTemplatingFileGenerator", "10.0.0.0")]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal sealed class <#= this.ClassName #> : ILicenseVerificationCache, ICacheProxyHolder
    {
        /// <summary>
        /// A <see cref="ILicenseVerificationCacheProxy"/> for the <see cref="<#= this.ClassName #>"/>.
        /// </summary>
        private sealed class Proxy : ILicenseVerificationCacheProxy
        {
            /// <summary>
            /// The owner object.
            /// </summary>
            private readonly <#= this.ClassName #> m_Owner;

            /// <summary>
            /// Initializes a new instance of the <see cref="Proxy"/> class.
            /// </summary>
            /// <param name="owner">The owner.</param>
            public Proxy(<#= this.ClassName #> owner)
            {
                {
                    Debug.Assert(owner != null, "The owner should not be null.");
                }

                m_Owner = owner;
            }

            /// <summary>
            /// Gets the latest verification result.
            /// </summary>
            /// <value>The latest result.</value>
            public LicenseCheckResult LatestResult
            {
                get
                {
                    return m_Owner.LatestResult;
                }
            }
        }

        /// <summary>
        /// The collection of proxies that link to other caches.
        /// </summary>
        private readonly List<ILicenseVerificationCacheProxy> m_Proxies =
            new List<ILicenseVerificationCacheProxy>();

        /// <summary>
        /// The object that performs the actual license validation.
        /// </summary>
        private readonly IValidator m_Validator;
        
        /// <summary>
        /// The function that returns the current time.
        /// </summary>
        private readonly Func<DateTimeOffset> m_Now;

        /// <summary>
        /// The function that returns a random double in the
        /// range [0, 1]
        /// </summary>
        private readonly Func<double> m_Random;

<#
    string lastResultField = "m_LastResult";
#>
        /// <summary>
        /// The latest license validation result.
        /// </summary>
        private LicenseCheckResult <#= lastResultField #>;

        /// <summary>
        /// Initializes a new instance of the <see cref="LicenseVerificationCache"/> class.
        /// </summary>
        /// <param name="validator">The validator that performs the actual license validation.</param>
        /// <param name="now">The function that returns the current time.</param>
        /// <param name="randomizer">The function that returns a random double in the range [0, 1].</param>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="validator"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="now"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// Thrown if <paramref name="randomizer"/> is <see langword="null"/>.
        /// </exception>
        public LicenseVerificationCache(IValidator validator, Func<DateTimeOffset> now, Func<double> randomizer)
        {
            {
                Enforce.Argument(() => validator);
                Enforce.Argument(() => now);
                Enforce.Argument(() => randomizer);
            }

            m_Validator = validator;
            m_Now = now;
            m_Random = randomizer;

<#
    string generationVariable = "generationTime";
    string expirationVariable = "expirationTime";
#>
            // Store the generation time and the expiration time. At the moment we'll assume
            // a 5 minute expiration time. Later on we should probably generate this arbitrairily.
            var <#= generationVariable #> = DateTimeOffset.Now;
            var <#= expirationVariable #> = <#= generationVariable #>.Add(new TimeSpan(0, 5, 0));

<#
    var checksumVariable = "checksum";
#>
            var <#= checksumVariable #> = new Checksum(<#= successText #>, <#= generationVariable #>, <#= expirationVariable #>);
            <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
        }

        /// <summary>
        /// Stores the specified proxy.
        /// </summary>
        /// <param name="proxy">The proxy.</param>
        public void Store(ILicenseVerificationCacheProxy proxy)
        {
            {
                Enforce.Argument(() => proxy);
            }

            m_Proxies.Add(proxy);
        }

        /// <summary>
        /// Gets the latest verification result.
        /// </summary>
        /// <value>The latest result.</value>
        public LicenseCheckResult LatestResult
        {
            get
            {
                return m_LastResult;
            }
        }

        /// <summary>
        /// Gets the last verification time.
        /// </summary>
        /// <value>The last verification time.</value>
        public DateTimeOffset LastVerificationTime
        {
            get
            {
                return m_LastResult.Generated;
            }
        }

        /// <summary>
        /// Invalidates the cache and gets a new <see cref="LicenseCheckResult"/> with the specified expiration time.
        /// </summary>
        /// <param name="nextExpiration">The <see cref="TimePeriod"/> that must occur before the validated
        /// license check expires.</param>
        public void Invalidate(TimePeriod nextExpiration)
        {
            // If there are no proxies then fail --> DONE
            if (m_Proxies.Count == 0)
            {
                var <#= generationVariable #> = m_Now();
                var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                var <#= checksumVariable #> = new Checksum(<#= failureText #>, <#= generationVariable #>, <#= expirationVariable #>);
                <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);

                // We're done here ...
                return;
            }

            // Check the proxies for their results
            var expiryTime = m_Now();
            
            // By setting the differential ticks to the number of ticks from now to
            // our desired expiry time we will either find something slightly shorter
            // or nothing. If nothing then we'll validate.
            var ourTicks = nextExpiration.RepeatAfter(m_Now()).Ticks;
            var differentialTicks = ourTicks;
            foreach (var proxy in m_Proxies)
            {
                var proxyResult = proxy.LatestResult;

                // If ALL the proxies have a success result then we grab 
                // the expiry time from the proxy with the expiry time
                // span that is closest to our own.
                var expiryPeriod = proxyResult.Expires - proxyResult.Generated;
                var difference = Math.Abs(expiryPeriod.Ticks - ourTicks);
                if (difference < differentialTicks)
                {
                    expiryTime = proxyResult.Expires;
                    differentialTicks = difference;
                }

                // if one of the proxies has failed then we fail too --> DONE
                var failureHash = "";
                if (string.Equals(failureHash, proxyResult.Checksum.ValidationHash, StringComparison.Ordinal))
                {
                    var <#= generationVariable #> = m_Now();
                    var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                    var <#= checksumVariable #> = new Checksum(<#= failureText #>, <#= generationVariable #>, <#= expirationVariable #>);
                    <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);

                    // We're done here ...
                    return;
                }
            }

            // Calculate the number of ticks left in the expiration time. Then
            // calculate the probability for validation in the range [0, 1] where
            // 1 is 100% of validation.
            var originalTicks = (expiryTime - m_Now()).Ticks;

            // The verificationPossibility will always be between zero and 1 because
            // originalTicks will be equal or less than ourTicks given that the expiryTime
            // was either 'now' or any time that is less than our expected expiry time
            var verificationPossibility = 1.0 - Math.Abs((double)originalTicks / (double)ourTicks);
            var value = m_Random();

            // If the value is less than the verificationPossibility then we'll need to verify
            // given that verificationPossibility will be 1.0 if we should verify.
            if (value < verificationPossibility)
            {
                // If we do validate then we call into the validation library
                // and wait for the result.
                // If we do validate then we call into the validation library
                // and wait for the result. --> DONE
                if (m_Validator.Validate())
                {
                    // If we do not validate then grab the success result and 
                    // build our own checksum
                    var <#= generationVariable #> = m_Now();
                    var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                    var <#= checksumVariable #> = new Checksum(<#= successText #>, <#= generationVariable #>, <#= expirationVariable #>);
                    <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
                }
                else
                {
                    // If we do not validate then grab the success result and 
                    // build our own checksum
                    var <#= generationVariable #> = m_Now();
                    var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                    var <#= checksumVariable #> = new Checksum(<#= failureText #>, <#= generationVariable #>, <#= expirationVariable #>);
                    <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
                }
            }
            else
            {
                // If we do not validate then grab the success result and 
                // build our own checksum
                var <#= generationVariable #> = m_Now();
                var <#= expirationVariable #> = generationTime + nextExpiration.RepeatAfter(<#= generationVariable #>);

                var <#= checksumVariable #> = new Checksum(<#= successText #>, <#= generationVariable #>, <#= expirationVariable #>);
                <#= lastResultField #> = new LicenseCheckResult(<#= generationVariable #>, <#= expirationVariable #>, <#= checksumVariable #>);
            }
        }

        /// <summary>
        /// Creates a new <see cref="ILicenseVerificationCacheProxy"/> object with the
        /// current cache as owner.
        /// </summary>
        /// <returns>
        ///     A new <see cref="ILicenseVerificationCacheProxy"/> object.
        /// </returns>
        public ILicenseVerificationCacheProxy CreateNewProxy()
        {
            return new Proxy(this);
        }
    }
}