//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------
<#@ include file="..\..\utils.srconly\Licensing\ChecksumHashCalculator.ttinclude" #>
using System;
using System.Diagnostics.CodeAnalysis;
<#
var apolloLicensingNamespace = "Apollo.Utils.Licensing";
if (!string.Equals(Namespace, apolloLicensingNamespace))
{
#>
using Apollo.Utils.Licensing;
<#
}
#>
using MbUnit.Framework;

namespace <#= Namespace #>
{
	[TestFixture]
    [Description("Tests the <#= ClassName #> class.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented",
            Justification = "Unit tests do not need documentation.")]
	public sealed class <#= ClassName #>
	{
		#region internal class - MockVerificationCache

        /// <summary>
        /// A mock implementation of a <see cref="ILicenseVerificationCache"/>.
        /// </summary>
        private sealed class MockVerificationCache : ILicenseVerificationCache
        {
            /// <summary>
            /// The action that is executed when the invalidate method is called.
            /// </summary>
            private readonly Action<TimePeriod> m_InvalidateAction;

            /// <summary>
            /// Initializes a new instance of the <see cref="MockVerificationCache"/> class.
            /// </summary>
            /// <param name="result">The next verification result.</param>
            /// <param name="invalidateAction">The action that will be invoked when the Invalidate method is called.</param>
            public MockVerificationCache(LicenseCheckResult result, Action<TimePeriod> invalidateAction)
            {
                LatestResult = result;
                m_InvalidateAction = invalidateAction;
            }

            /// <summary>
            /// Gets the latest verification result.
            /// </summary>
            /// <value>The latest result.</value>
            public LicenseCheckResult LatestResult
            {
                get;
                private set;
            }

            /// <summary>
            /// Gets the last verification time.
            /// </summary>
            /// <value>The last verification time.</value>
            public DateTimeOffset LastVerificationTime
            {
                get
                {
                    return LatestResult.Generated;
                }
            }

            /// <summary>
            /// Invalidates the cache and gets a new <see cref="LicenseCheckResult"/> with the specified expiration time.
            /// </summary>
            /// <param name="nextExpiration">
            /// The <see cref="TimePeriod"/> that must occur before the validated
            /// license check expires.
            /// </param>
            public void Invalidate(TimePeriod nextExpiration)
            {
                m_InvalidateAction(nextExpiration);
            }

            /// <summary>
            /// Creates a new <see cref="ILicenseVerificationCacheProxy"/> object with the
            /// current cache as owner.
            /// </summary>
            /// <returns>
            ///     A new <see cref="ILicenseVerificationCacheProxy"/> object.
            /// </returns>
            public ILicenseVerificationCacheProxy CreateNewProxy()
            {
                // Do nothing for now ...
                throw new NotImplementedException();
            }
        }
        
        #endregion

		[Test]
        [Description("Checks that an object cannot be created without a verification cache.")]
        public void CreateWithNullCache()
        {
            Assert.Throws<ArgumentNullException>(() => new <#= ClassUnderTest #>(null, (sum, offset) => { }, () => DateTimeOffset.Now));
        }

        [Test]
        [Description("Checks that an object cannot be created without a verification result function.")]
        public void CreateWithNullValidationResult()
        {

            Assert.Throws<ArgumentNullException>(() => new <#= ClassUnderTest #>(new MockVerificationCache(new LicenseCheckResult(), (TimePeriod period) => { }), null, () => DateTimeOffset.Now));
        }

        [Test]
        [Description("Checks that an object cannot be created without a current date/time function.")]
        public void CreateWithNullDateTimeFunction()
        {
            Assert.Throws<ArgumentNullException>(() => new <#= ClassUnderTest #>(new MockVerificationCache(new LicenseCheckResult(), (TimePeriod period) => { }), (sum, offset) => { }, null));
        }

        [Test]
        [Description("Checks that the validation fails when a verification result is from the future, even if the invalidation of the cache fails.")]
        public void VerifyWithGeneratedResultInTheFutureAndFailingCacheInvalidate()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            validator.Verify();

            var failChecksum = new Checksum(<#= failureText #>, currentTime, currentTime.AddHours(1));
            Assert.IsTrue(failChecksum.Equals(checksum));
		}

        [Test]
        [Description("Checks that the validation fails when a verification result is from the future.")]
        public void VerifyWithGeneratedResultInTheFuture()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            validator.Verify();

            var failChecksum = new Checksum(<#= failureText #>, currentTime, currentTime.AddHours(1));
            Assert.IsTrue(failChecksum.Equals(checksum));
		}

        [Test]
        [Description("Checks that the validation fails when a verification result has expired and the invalidation of the cache fails.")]
        public void VerifyWithExpiryTimeInThePastAndFailingCacheInvalidate()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            validator.Verify();

            var failChecksum = new Checksum(<#= failureText #>, currentTime, currentTime.AddHours(1));
            Assert.IsTrue(failChecksum.Equals(checksum));
		}

        [Test]
        [Description("Checks that the validation runs correctly when a verification result has expired.")]
        public void VerifyWithExpiryTimeInThePast()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            validator.Verify();
            Assert.IsTrue(original.Equals(checksum));
		}

		[Test]
        [Description("Checks that the validation fails when a verification result is from the future, even if the invalidation of the cache fails.")]
        public void VerifyWithTimePeriodWithGeneratedResultInTheFutureAndFailingCacheInvalidate()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

			var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);

            var failChecksum = new Checksum(<#= failureText #>, currentTime, currentTime + nextExpiration.RepeatAfter(currentTime));
            Assert.IsTrue(failChecksum.Equals(checksum));
		}

        [Test]
        [Description("Checks that the validation fails when a verification result is from the future.")]
        public void VerifyWithTimePeriodWithGeneratedResultInTheFuture()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);

            var failChecksum = new Checksum(<#= failureText #>, currentTime, currentTime + nextExpiration.RepeatAfter(currentTime));
            Assert.IsTrue(failChecksum.Equals(checksum));
		}

        [Test]
        [Description("Checks that the validation fails when a verification result has expired and the invalidation of the cache fails.")]
        public void VerifyWithTimePeriodWithExpiryTimeInThePastAndFailingCacheInvalidate()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);

            var failChecksum = new Checksum(<#= failureText #>, currentTime, currentTime + nextExpiration.RepeatAfter(currentTime));
            Assert.IsTrue(failChecksum.Equals(checksum));
		}

        [Test]
        [Description("Checks that the validation runs correctly when a verification result has expired.")]
        public void VerifyWithTimePeriodWithExpiryTimeInThePast()
        { 
			var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = <#= successText #>;
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockVerificationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, offset) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new <#= ClassUnderTest #>(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);
            Assert.IsTrue(original.Equals(checksum));
		}
	}
}