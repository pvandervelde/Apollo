//-----------------------------------------------------------------------
// <copyright company="P. van der Velde">
//     Copyright (c) P. van der Velde. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//
//-----------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on 2010-07-26T20:52:33.6573151+12:00.
//
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;
using MbUnit.Framework;

namespace Apollo.Utils.Licensing
{
    [TestFixture]
    [Description("Tests the LicenseValidatorTest class.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented",
            Justification = "Unit tests do not need documentation.")]
    public sealed class LicenseValidatorTest
    {
        #region internal class - MockValidationCache

        /// <summary>
        /// A mock implementation of a <see cref="ILicenseValidationCache"/>.
        /// </summary>
        private sealed class MockValidationCache : ILicenseValidationCache
        {
            /// <summary>
            /// The action that is executed when the invalidate method is called.
            /// </summary>
            private readonly Action<TimePeriod> m_InvalidateAction;

            /// <summary>
            /// Initializes a new instance of the <see cref="MockValidationCache"/> class.
            /// </summary>
            /// <param name="result">The next validation result.</param>
            /// <param name="invalidateAction">The action that will be invoked when the Invalidate method is called.</param>
            public MockValidationCache(LicenseCheckResult result, Action<TimePeriod> invalidateAction)
            {
                LatestResult = result;
                m_InvalidateAction = invalidateAction;
            }

            /// <summary>
            /// Gets the latest validation result.
            /// </summary>
            /// <value>The latest result.</value>
            public LicenseCheckResult LatestResult
            {
                get;
                private set;
            }

            /// <summary>
            /// Gets the last validation time.
            /// </summary>
            /// <value>The last validation time.</value>
            public DateTimeOffset LastValidationTime
            {
                get
                {
                    return LatestResult.Generated;
                }
            }

            /// <summary>
            /// Invalidates the cache and gets a new <see cref="LicenseCheckResult"/> with the specified expiration time.
            /// </summary>
            /// <param name="nextExpiration">
            /// The <see cref="TimePeriod"/> that must occur before the validated
            /// license check expires.
            /// </param>
            public void Invalidate(TimePeriod nextExpiration)
            {
                m_InvalidateAction(nextExpiration);
            }

            /// <summary>
            /// Creates a new <see cref="ILicenseValidationCacheProxy"/> object with the
            /// current cache as owner.
            /// </summary>
            /// <returns>
            ///     A new <see cref="ILicenseValidationCacheProxy"/> object.
            /// </returns>
            public ILicenseValidationCacheProxy CreateNewProxy()
            {
                // Do nothing for now ...
                throw new NotImplementedException();
            }
        }
        
        #endregion

        [Test]
        [Description("Checks that an object cannot be created without a validation cache.")]
        public void CreateWithNullCache()
        {
            Assert.Throws<ArgumentNullException>(() => new LicenseValidator(null, (sum, generated, expires) => { }, () => DateTimeOffset.Now));
        }

        [Test]
        [Description("Checks that an object cannot be created without a validation result function.")]
        public void CreateWithNullValidationResult()
        {

            Assert.Throws<ArgumentNullException>(() => new LicenseValidator(new MockValidationCache(new LicenseCheckResult(), (TimePeriod period) => { }), null, () => DateTimeOffset.Now));
        }

        [Test]
        [Description("Checks that an object cannot be created without a current date/time function.")]
        public void CreateWithNullDateTimeFunction()
        {
            Assert.Throws<ArgumentNullException>(() => new LicenseValidator(new MockValidationCache(new LicenseCheckResult(), (TimePeriod period) => { }), (sum, generated, expires) => { }, null));
        }

        [Test]
        [Description("Checks that the validation fails when a validation result is from the future, even if the invalidation of the cache fails.")]
        public void VerifyWithGeneratedResultInTheFutureAndFailingCacheInvalidate()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            Assert.Throws<LicenseValidationFailedException>(() => validator.Verify());
        }

        [Test]
        [Description("Checks that the validation fails when a validation result is from the future.")]
        public void VerifyWithGeneratedResultInTheFuture()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            validator.Verify();

            var failChecksum = new Checksum("ValidationFailure", currentTime, currentTime.AddHours(1));
            Assert.IsTrue(failChecksum.Equals(checksum));
        }

        [Test]
        [Description("Checks that the validation fails when a validation result has expired and the invalidation of the cache fails.")]
        public void VerifyWithExpiryTimeInThePastAndFailingCacheInvalidate()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            validator.Verify();

            var failChecksum = new Checksum("ValidationFailure", currentTime, currentTime.AddHours(1));
            Assert.IsTrue(failChecksum.Equals(checksum));
        }

        [Test]
        [Description("Checks that the validation runs correctly when a validation result has expired.")]
        public void VerifyWithExpiryTimeInThePast()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            validator.Verify();
            Assert.IsTrue(original.Equals(checksum));
        }

        [Test]
        [Description("Checks that the validation fails when a validation result is from the future, even if the invalidation of the cache fails.")]
        public void VerifyWithTimePeriodWithGeneratedResultInTheFutureAndFailingCacheInvalidate()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            Assert.Throws<LicenseValidationFailedException>(() => validator.Verify(nextExpiration));
        }

        [Test]
        [Description("Checks that the validation fails when a validation result is from the future.")]
        public void VerifyWithTimePeriodWithGeneratedResultInTheFuture()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddDays(1);
            var expires = generated.AddDays(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);

            var failChecksum = new Checksum("ValidationFailure", currentTime, currentTime + nextExpiration.RepeatAfter(currentTime));
            Assert.IsTrue(failChecksum.Equals(checksum));
        }

        [Test]
        [Description("Checks that the validation fails when a validation result has expired and the invalidation of the cache fails.")]
        public void VerifyWithTimePeriodWithExpiryTimeInThePastAndFailingCacheInvalidate()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { throw new Exception(); });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);

            var failChecksum = new Checksum("ValidationFailure", currentTime, currentTime + nextExpiration.RepeatAfter(currentTime));
            Assert.IsTrue(failChecksum.Equals(checksum));
        }

        [Test]
        [Description("Checks that the validation runs correctly when a validation result has expired.")]
        public void VerifyWithTimePeriodWithExpiryTimeInThePast()
        { 
            var currentTime = DateTimeOffset.Now;
            var generated = DateTimeOffset.Now.AddHours(-2);
            var expires = generated.AddHours(1);
            var text = "ValidationSuccess";
            var original = new Checksum(text, generated, expires);
            var result = new LicenseCheckResult(generated, expires, original);

            var cache = new MockValidationCache(result, (TimePeriod period) => { });

            // Create a storage for the output and assign it a bogus value. 
            // The compiler doesn't see that we'll have an assigned value before checking.
            Checksum checksum = new Checksum();

            LicenseResultUpdated onValidationResult = (sum, generationTime, expirationTime) => { checksum = sum; };
            Func<DateTimeOffset> now = () => currentTime;
            var validator = new LicenseValidator(cache, onValidationResult, now);

            var nextExpiration = new TimePeriod(RepeatPeriod.Weekly);
            validator.Verify(nextExpiration);
            Assert.IsTrue(original.Equals(checksum));
        }
    }
}
